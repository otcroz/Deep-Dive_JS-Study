## 13-1. 스코프란?

**스코프**: **식별자의 유효 범위**, 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자를 참조할 수 있는 유효 범위가 달라진다.

아래 예시에서 x는 함수 내에서 사용된 매개변수이기에 에러가 발생한다.

```jsx
function add(x, y) {
  // 매개변수의 스코프(유효범위)는 함수 몸체 내부
  console.log(x, y); // 2 5
  return x + y;
}

add(2, 5);

// 매개변수는 함수 몸체 내부에서만 참조 가능
console.log(x, y); // ReferenceError: x is not defined
```

또한, 동일한 이름의 식별자여도 스코프에 따라서 출력되는 값이 다르다. 

```jsx
var x = 'global'; // 전역으로 사용되는 변수, global 스코프

function foo() {
  var x = 'local'; // foo 함수 내부에서만 참조하는 변수, local 스코프
  console.log(x); // ① 
}

foo();

console.log(x); // ② 
```

**식별자 결정**: 같은 변수명을 사용했을 때, JS 엔진은 어떤 변수를 참조할 것인지 결정해야 함.

스코프는 **JS 엔진이 식별자를 검색할 때 사용하는 규칙으로,** 스코프 내에서 식별자는 유일하지만 다른 스코프에서는 같은 이름을 사용할 수 있다. 즉, 스코프는 **네임스페이스**

 
>💡파일 이름은 하나의 파일을 구별하여 사용해야 하지만, 디렉터리가 있기에 파일 이름을 중복해서 사용할 수 있다. 이때 디렉터리는 **스코프**이다.

 

 
>💡var 키워드로 선언된 변수는 같은 스코프 내에서 **중복 선언을 허용한다. 재할당되어 값을 변경할 수 있다.**

```jsx
function foo() {
  var x = 1;
  
  var x = 2;
  console.log(x); // 2
}
foo();
```

let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 **중복 선언을 허용하지 않는다.**

```jsx
function bar() {
  let x = 1;
  let x = 2; // SyntaxError: Identifier 'x' has already been declared
}
bar();
```

 

---

## 13-2. 스코프의 종류

- **전역/전역 스코프/전역 변수**: 코드의 가장 바깥 영역, **어디서든지 참조** 가능
- **지역/지역 스코프/지역 변수**: 함수 몸체 내부, **자신의 스코프와 하위 스코프에서만 유효**

<img width="579" height="503" alt="image" src="https://github.com/user-attachments/assets/7dfa7918-0006-47aa-8ade-134f3f966bbe" />


---

## 13-3. 스코프 체인

- **중첩 함수(nested function)**: 함수 몸체 내부에서 정의한 함수
- **외부 함수(outer function)**: 중첩 함수를 포함하는 함수

함수가 중첩될 수 있으므로, 지역 스코프가 중첩될 수 있다. 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다. **즉, 중첩 함수의 지역 스코프는 외부 함수의 지역 스코프와 계층적 구조를 갖는다.**

- **스코프 체인**: 모든 스코프는 **하나의 계층적 구조**로 연결되며, 모든 지역 스코프의 최상위 스코프는 전역 스코프.

<img width="332" height="566" alt="image" src="https://github.com/user-attachments/assets/b63f17cb-4883-4b07-84a2-3877f46eb6f1" />


**변수를 참조할 때 JS 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작해 상위 스코프 방향으로 이동하며 선언된 변수를 검색** ⇒ 상위 스코프에서 선언한 변수를 하위에서 참조할 수 있음.

JS 엔진은 코드를 실행하기 전 **렉시컬 환경**을 실제로 생성. 변수 선언이 실행되면 변수 식별자가 렉시컬 환경에 키로 등록되고, 변수 할당이 일어나면 변수 식별자에 해당하는 값을 변경.

변수의 검색도 렉시컬 환경에서 이루어짐.

 
>❓
>  - **렉시컬 환경**: 코드가 어디서 실행되며 주변에 어떤 코드가 있는지 구현한 이론상의 객체
>  - **실행 컨텍스트**: scope, hoisting, this, function, closure 등의 동작원리를 담고 있는 자바스크립트의 핵심원리
 

스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것.

### 1) 스코프 체인에 의한 변수 검색

<img width="554" height="461" alt="image" src="https://github.com/user-attachments/assets/19615291-b61d-4435-be26-ca2b40fb37f3" />


④: x 변수를 참조하는 inner 함수의 지역 스코프에서 x 선언 검색 → 검색되면 참조하고 종료

⑤: y 변수를 참조하는 inner 함수의 지역 스코프에서 y 선언 검색 → 상위 스코프인 outer 함수의 지역 스코프로 이동해 y 선언 검색 → 전역 스코프에 존재하는 y 선언 참조 후 종료

⑥: z 변수를 참조하는 inner 함수의 지역 스코프에서 z 선언 검색 → 상위 스코프인 outer 함수의 지역 스코프로 이동해 y 선언 검색 → 검색되면 참조하고 종료

**이는 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만, 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.**

### 2) 스코프 체인에 의한 함수 검색

```jsx
// 전역 함수
function foo() {
  console.log('global function foo');
}

function bar() {
  // 중첩 함수
  function foo() {
    console.log('local function foo');
  }

  foo(); // local function foo
}

bar();
```

JS 엔진은 함수 선언문으로 함수를 선언했을 때, 런타임 이전에 함수 객체를 생성한다. 그리고 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.

즉, **모든 함수는 함수 이름과 동일한 이름의 식별자에 할당**한다. foo 함수를 호출하면 JS 엔진은 **먼저 함수를 가리키는 식별자 foo**를 검색한다.

---

## 13-4. 함수 레벨 스코프

- **블록 레벨 스코프**: 모든 코드 블록(if, for, while, try/catch)이 지역 스코프를 만듦
- **함수 레벨 스코프**: var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정 → 나머지는 전역으로 인지

```jsx
var x = 1;

if (true) {
  var x = 10;
}

console.log(x); // 10
```

예시에서 x는 전역 변수이다. 이미 선언된 전역 변수 x가 있으므로 x 변수는 중복 선언되었으며, 의도치 않게 변수 값이 변경되는 부작용을 발생시킨다.

```jsx
var i = 10;
for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

console.log(i); // 5
```

또한, for 문에서 선언한 i는 전역 변수다. 이미 선언된 전역 변수 i가 있으므로 중복 선언되어 값을 재할당한다.

 
>💡var로 선언된 변수는 함수의 코드 블록만을 지역 스코프로 인정하지만, ES6 이후에 도입된 let, const는 블록 레벨 스코프를 지원한다.

 

---

## 13-5. 렉시컬 스코프

1. **동적 스코프**: 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정
2. **렉시컬 스코프(=정적 스코프)**: 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정

 
>💡JS를 포함한 대부분의 프로그래밍 언어는 **렉시컬 스코프**를 따른다.

 

```jsx
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

즉, JS는 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다. 

예시에서 bar 함수는 전역에서 정의된 함수로, 생성된 bar 함수 객체는 자신이 정의된 전역 스코프를 기억한다.
