데이터 타입(숫자, 문자열, 불리언, null, undefined, 심벌,  객체)은 **원시 타입**과 **객체 타입**으로 구분된다.

- **원시 타입**
    - 변경 불가능한 값
    - 변수에 원시 값을 할당하면 메모리에 실제 값 저장
    - **값에 의한 전달**: 원시 값을 갖는 변수를 다른 변수에 할당하면 **원시 값이 복사**되어 전달
    

- **객체 타입**
    - 변경 가능한 값
    - 변수에 객체를 할당하면 메모리에 참조 값 저장
    - **참조에 의한 전달**: 객체 참조 값을 갖는 변수를 다른 변수에 할당하면 **원본의 참조 값이 복사**되어 전달

---

## 11-1. 원시 값

### 1) 변경 불가능한 값

- 원시 타입의 값은 변경 불가능 → 한 번 생성된 원시 값은 **읽기 전용 값**으로서 변경할 수 없음.
- 원시 값의 특성은 데이터의 신뢰성 보장


**값을 변경할 수 없는 것은 무슨 의미일까?**

- 변수의 값을 변경할 수 없는 것이 아니라, 값 자체를 변경할 수 없다는 것이다.
- 즉, 변수에 할당된 값은 재할당을 통해 **변경할 수 있다!**

**변수 ↔ 상수**

- 상수는 재할당이 금지된 변수
- 한 번 선언하면 변수에 선언된 **원시 값을 변경할 수 없다!**
- 하지만 const 키워드로 선언한 변수에 **할당한 객체는 변경할 수 있다.**

```jsx
const o = {}; // const로 객체 선언
o.a = 1;
console.log(o); // {a: 1}
```

- **불변성**: 변수에 새로운 원시 값을 재할당하면, 메모리 공간에 저장된 이전의 값을 변경하는 것이 아닌 **새로운 메모리 공간을 확보**하고 재할당한 원시값을 저장한 후, **변수는 재할당된 원시 값을 가리킨다**.
- 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 방법이 없다.
    - 변수 값을 변경할 수 있게 되면? 예기치 않게 값이 변경되어 상태 변경을 추적하기 어려움

<img width="783" height="356" alt="image" src="https://github.com/user-attachments/assets/b2a27558-65d5-42e1-a283-154fc6d24bf4" />


### 2) 문자열과 불변성

- 원시 값을 저장하려면 먼저 확보해야 하는 메모리 공간 크기를 결정해야 한다.
- 하지만 ECMAScript 사양에 문자열 타입과 숫자 타입 이외 원시 타입은 크기를 명확하게 정의하지 X, 브라우저에 따라 다를 수 있다.

>❓문자열
>
>- 0개 이상의 문자로 이루어진 집합, 1개의 문자는 2바이트의 메모리 공간에 저장
>- 문자열은 몇 개의 문자로 이뤄졌느냐에 따라 메모리 공간의 크기가 결정
>
>e.g. 숫자는 1, 100000 모두 동일한 8바이트 필요, 1개 문자는 2바이트, 10개 문자는 20바이트
>
>- 유사 배열 객체면서 이터러블 → 배열 객체와 유사하게 문자에 접근 O


JS는 원시 타입인 문자열 타입을 제공하며 변경 불가능하다. 

아래 예시는 hello와 world 모두 메모리에 저장되어 있으며, 변수는 hello가 저장된 메모리 공간을 가리키다가 재할당된 순간에 world를 가리키도록 변경된 것이다.

```jsx
var str = 'hello';
str = 'world';
```

 
>❓**유사배열 객체**
>
>- 배열처럼 **인덱스**로 프로퍼티 값에 접근할 수 있으며, length 프로퍼티를 갖는 객체
>- for 문으로 순회 O

```jsx
var str = 'string';
str[0] = 'S'; // 문자열은 원시값이므로 변경할 수 없다. 이때, 에러가 발생하지 않는다.
console.log(str);
```

원시 값은 `str[0] = 'S'` 처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다. 그렇지만 변수에 새로운 문자열을 재할당하는 것은 가능하다.

 

### 3) 값에 의한 전달

**값에 의한 전달**: 변수에 원시 값을 갖는 변수를 할당하면 할당 받는 변수에 할당 되는 변수의 원시 값이 복사되어 전달

 
>💡변수는 값이 아니라 메모리 주소를 기억하고 있기 때문에, 값에 의한 전달은 직접적으로 값을 전달하는 것이 아니라 **메모리 주소를 전달**하는 것이다. 

메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.

 

값에 의한 전달(할당, 재할당 등등)이 이루어지면, 두 변수의 원시값을 서로 다른 메모리에 저장된 별개의 값이 된다. 따라서, score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.

```jsx
var score = 80;

// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy);    // 80  80
console.log(score === copy); // true

score = 100;

console.log(score, copy);    // 100  80
console.log(score === copy); // false
```

<img width="596" height="293" alt="image" src="https://github.com/user-attachments/assets/c7c40e90-5c29-4dab-8b78-3960ac80e59a" />


---

## 11-2. 객체

 
>❓**객체**
>
>프로퍼티의 개수가 정해져 있지 않아, 메모리 공간의 크기를 사전에 정할 수 없다.
>
>원시 값은 상대적으로 적은 메모리를 소비하지만, 객체는 경우에 따라 크게 달라진다.
>
>⇒ 객체 생성 후 프로퍼티에 접근하는 작업이 원시값과 비교할 때 많은 비용이 든다.

 

 
>💡**JS 객체의 관리 방식**
>
>JS 객체는 프로퍼티 키를 인덱스로 사용하는 해시테이블과 유사하다.
>
>클래스 없이 객체를 생성할 수 있으며, 객체 생성 이후에 동적으로 프로퍼티, 메서드 추가 O

<img width="278" height="220" alt="image" src="https://github.com/user-attachments/assets/6c275346-6b1f-4fbe-9718-8dd51d1388de" />


사용하기 편리하지만 객체 생성, 프로퍼티 접근 비용이 더 많이 드는 비효율적인 방식

⇒ 프로퍼티에 접근하기 위해 동적 탐색 대신 **히든 클래스**를 사용해 성능을 보장

 

### 1) 변경 가능한 값

객체(참조) 타입은 변경 가능한 값

```jsx
// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성된다.
var person = {
  name: 'Lee'
};

// person 변수에 저장되어 있는 참조값으로 실제 객체에 접근해서 그 객체를 반환한다.
console.log(person); // {name: "Lee"}
```

변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하여 참조 값에 접근할 수 있다.

즉, 객체를 할당한 변수는 메모리 공간의 주소(= 참조 값)를 갖는다.

<img width="479" height="371" alt="image" src="https://github.com/user-attachments/assets/edd16be7-053f-48c3-8bda-3298ef313bc2" />


객체는 변경 가능한 값이기에 재할당 없이 객체를 직접 변경할 수 있다.

**즉, 재할당 없이 프로퍼티 추가 및 갱신, 삭제 가능**

```jsx
var person = {
  name: 'Lee'
};

// 프로퍼티 값 갱신
person.name = 'Kim';

// 프로퍼티 동적 생성
person.address = 'Seoul';

console.log(person); // {name: "Kim", address: "Seoul"}
```

객체를 생성하고 관리하는 방식은 매우 복잡하고 비용이 많이 드는 일이기에, 효율적인 메모리 사용을 위해 객체는 변경 가능한 값으로 설계되어 있다.

하지만 구조적 단점은 **여러 개의 식별자가 하나의 객체를 공유할 수 있다는 점이다.**

 
>💡**얕은 복사와 깊은 복사**
>
>- 얕은 복사: 객체의 참조 값을 복사
>- 깊은 복사: 원본 객체의 완전한 복사본을 생성
>
>```jsx
>const o = { x: { y: 1 } };
>
>// 얕은 복사
>const c1 = { ...o }; // 35장 "스프레드 문법" 참고
>console.log(c1 === o); // false
>console.log(c1.x === o.x); // true
>
>// 깊은 복사
>const _ = require('lodash');
>const c2 = _.cloneDeep(o);
>console.log(c2 === o); // false
>console.log(c2.x === o.x); // false
>```
>
>원시 값을 할당한 변수를 다른 변수에 할당하는 것을 **깊은 복사**, 객체를 할당한 변수를 다른 변수에 할당하는 것을 **얕은 복사**라고도 한다.
>
>```jsx
>const v = 1;
>
>// 원시 값의 "깊은 복사"
>const c1 = v;
>console.log(c1 === v); // true
>
>const o = { x: 1 };
>
>// 참조 값의 "얕은 복사"
>const c2 = o;
>console.log(c2 === o); // true
>```

 

### 2) 참조에 의한 전달

원본의 참조 값이 복사되어 전달된다. 즉, **두 개의 식별자가 하나의 객체를 공유**한다.

<img width="797" height="402" alt="image" src="https://github.com/user-attachments/assets/81c4094d-f4cf-4551-b0c1-8e03a57fe56e" />

아래 예시에서도 copy는 person과 동일한 메모리 공간을 가리키고 있기에, 값을 변경하는 과정에서 객체에 영향을 주었으며, 동일한 값이 출력되는 것을 확인할 수 있다.

```jsx
var person = {
  name: 'Lee'
};

// 참조값을 복사(얕은 복사)
var copy = person;

// copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); // true

copy.name = 'Kim';
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리킨다.
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy);   // {name: "Kim", address: "Seoul"}
```

일치 비교 연산자(===)는 변수에 저장되어 있는 값을 타입 변환하지 않고 비교한다.

이 연산자를 통해 **객체를 할당한 변수**를 비교하면 참조 값을 비교, **원시 값을 할당한 변수**를 비교하면 원시 값을 비교한다.

```jsx
var person1 = {
  name: 'Lee'
};

var person2 = {
  name: 'Lee'
};

console.log(person1 === person2); // false, 서로 다른 메모리 공간에 있는 객체
console.log(person1.name === person2.name); // true, 값 자체는 동일
```
